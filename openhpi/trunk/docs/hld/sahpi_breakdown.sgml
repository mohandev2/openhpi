<!-- ...................................................................... -->
<!-- $Id$ ......................................... -->
<!-- 
        This material may be distributed only subject to the terms and 
        conditions set forth in the Open Publication License, v1.0 or later 
        (the latest version is currently available at 
        http://www.opencontent.org/openpub/).  Distribution of substantively 
        modified version of this document is prohibited without the explicit 
        permission of the copyright holder.

        Other company, product, or service names may be trademarks or service 
        marks of others.
-->

<chapter>
  <title>Overview of SA HPI - 10,000 foot view</title>
  <para>The following chapter is designed as a primer on the SA HPI
    specification.  It is meant to represent the OpenHPI teams
    interpretation and explaination of various portions of the spec as we
    see it, and to help new users and developers come up to speed quickly
    in understanding the specification.  This chapter should always be
    considered a work in progress, and any questions or comments on it
    should be sent to the openhpi-devel@lists.sf.net mailing list.
  </para>
  <sect1>
    <title>Resource Model</title>
    <sect2>
      <title>Resources</title>
      <para>
        HPI provides a platform management interface which is entirely
        based on resources.  The crux of the entire HPI model is the
        Resource Presence Table (RPT).  Everything which can exist
        physically is represented in the RPT.  Every domain (we'll
        address domains later) contains one, and only one RPT.
      </para>
      <para>
        The RPT is a concept in HPI, though it isn't actually a data
        structure.  It is expected that implementers will create the
        proper data structure to encapsulate it.  What is specified is 2
        types of information:
      </para>
      <itemizedlist mark='opencircle'>
        <listitem>
          <para><emphasis>SaHpiRptInfoT</emphasis> - a meta data structure that
            contains the update time and incremental counter for the RPT.
          </para>
        </listitem>
        <listitem>
          <para><emphasis>SaHpiRptEntryT</emphasis> - The actually Resource
            Presence Table entries. It is expected that there will be
            many of them.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        From here on in the term Resource will be synonymous with an
        object of SaHpiRptEntryT type.
      </para>
    </sect2>
    <sect2>
      <title>Resource Capabilities</title>
      <para>
        Every Resource has one field dedicated to capabilities of the
        resource.  This field is a 32bit vector, each bit
        corresponding to a capability.  They include:
      </para>
      <itemizedlist mark='opencircle'>
        <listitem>
          <para><emphasis>SAHPI_CAPABILITY_DOMAIN</emphasis> - the
            resource is a domain.
          </para>
        </listitem>
        <listitem>
          <para><emphasis>SAHPI_CAPABILITY_SEL</emphasis> - the
            resource has a system event log associated with it.
          </para>
        </listitem>
        <listitem>
          <para><emphasis>SAHPI_CAPABILITY_RDR</emphasis> - the
            resource has a rdr entries associated with it.  This is
            mandatory with HPI 1.0.
          </para>
        </listitem>
        <listitem>
          <para><emphasis>SAHPI_CAPABILITY_FRU</emphasis> - the
            resource is a field replacable unit.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        There are many more capabilities as well.  For a full list,
        see page 103 of the HPI 1.0 Specification.
      </para>
    </sect2>
    <sect2>
      <title>Entity Path</title>
      <para>
        Resources are the logic representation of physical things.
        They may be a rack, a chassis, or a cpu.  Internal to HPI all
        resources are identified by a ResourceId.  However, the
        enumeration of this value is very implementation specific, so
        may not always be the best way to refer to resources.
      </para>
      <para>
        All resources in HPI have an entity path.  This is a 16
        element array of SaHpiEntityT structures.  The structure
        defines an entity type, and an instance number.  For instance:
        <literal>SAHPI_ENT_DISK_BAY 0</literal>.  The entity paths
        provide the real world physical topology of the resources.  So
        it could be well understood that the resource with
        ResourceId=37 was a CPU contained in the chassis which is
        ResourceId=21.  Entity paths <emphasis>must be
          unique</emphasis> within the context of a single Resource
        Presence Table.
      </para>
      <para>
        HPI entity paths go from least significant to most
        significant (i.e. the element to the right in the array is the
        container for the element on its left).
      </para>
      <para>
        <emphasis>OpenHPI Note:</emphasis> for the purposes of
        portibility OpenHPI has created a canonical string
        representation of the entity path.  It involves removing the
        SAHPI_ENT_ prefix from the types, and creating tuples for the
        entity types.  Order of significance is inverted to make
        entity paths look more like Unix directory structure. It is
        also assumed that {ROOT,0} exists implicitly before all of
        these entries.  Examples look as follows:
      </para>
      <itemizedlist mark='opencircle'>
        <listitem>
          <para>{SYSTEM_CHASSIS,2}{PROCESSOR_BOARD,0}</para>
        </listitem>
        <listitem>
          <para>{COMPACTPCI_CHASSIS,1}{IO_BLADE,12}</para>
        </listitem>
      </itemizedlist>
   </sect2>
    <sect2>
      <title>Resource Data Records</title>
      <para>
        Associated with every Resource are Resource Data Records
        (RDRs).  <literal>SAHPI_CAPABILITY_RDR</literal> is required
        to be on for all resources in HPI 1.0 (this appears to be
        changing based on early errata released).  There is a many to
        one relationship between RDRs and Resources, and it is
        expected that all resources will have many RDRs.
      </para>
      <para>
        RDRs come in 4 types: Sensor, Control, Inventory, or
        Watchdog.  Where the Resources represent a physical object,
        the RDRs represent a quality of that object.  For instance a
        Motherboard (a Resource) may have many thermal sensors (Sendor
        RDRs), voltage sensors (Sensor RDRs), remote power control
        (Control RDR), programable leds (Control RDRs), and inventory
        function (Inventory RDR).
      </para>
      <para>
        The connecting element in the relationship between RDRs and
        Resources is the entity path.  Although entity path will
        uniquely identify a Resource, it will identify one or more
        RDRs that are associated with that Resource.
      </para>
    </sect2>
    <sect1>
      <title>Event Model</title>
      <para>
        If Resources are the nouns of HPI, Events are the verbs.
        Based on flags set on Resources, events will be generated by
        changes in RDR values.  This section attempts to clarify what
        events mean in an HPI context.
        <sect2>
          <title>System Event Logs</title>
          <para>
            If a Resource has the <literal>SAHPI_CAPABILITY_SEL</literal>
            bit set, there is a System Event Log (SEL) associated with that
            resource.  The SEL is a repository for events
            that can later be retrieved via HPI calls.  SELs come in 2 flavors, Domain Level,
            and Resource Level.
          </para>
          <para>
            A Domain Level SEL is implemented in software, and
            contains events associated with the domain.  There is
            exactly one Domain level SEL per domain.  These may
            have been generated because HPI has been told to monitor
            the temperature of a sensor, and on the latest polling for
            that data, the sensor exceeded the threshold.  The
            important part to remember is that the events in the
            Domain level SEL are HPI originated, based on rulesets in
            HPI.
          </para>
          <para>
            A Resource (which is not a domain) will have the
            <literal>SAHPI_CAPABILITY_DOMAIN</literal> bit turned on
            if that resource represents a piece of hardware which
            contains a hardware implemented SEL.  For instance, most
            server mother boards have an SEL that monitors what the
            hardware considers critical events.  This may include a
            fan failure, a boot failure, or other events.  Unlike
            Domain level SELs, the decision mechanism for what events
            get generated in a Resource SEL are not under the control
            of HPI.  They are hardcoded in the hardware directly.
          </para>
          <para>
            There may be mechanisms for changing what events get
            generated in an Resource SEL.  However, those controls are
            beyond the scope of HPI.
          </para>
          <note>
            <para>SLD: Did I get this right?  Seems odd, perhaps it is
              too late on friday</para>
          </note>
        </sect2>
    </sect1>
    <sect1>
      <title>Domain Model</title>
      <para>
        The concept of Domains has come up a number of times in the
        design spec.  On even cursory reading of the HPI
        specification, it can be seen that domains take up a large
        portion of the specification.  Domains are arbitrary logical
        groupings of resources.  They can be overlapping (i.e. the
        same resource can appear in multiple domains), and they need
        not be hierarchical.
      </para>
      <para>
        The intended use of Domains appears to be as a security
        mechanism.  Page 18 of the HPI 1.0 specification describes
        domains to be used by a "Lanlord" to get access to a set of
        resources by a "Tenant".  A problem that arises from this
        interpretation is the requirement in HPI 1.0 that the security
        pointer to saHpiSessionOpen be NULL.  Because of this fact,
        privilege separation can not be acheived through the HPI
        interface in its current incarnation.
      </para>
      <para>
        Because of this fact, the OpenHPI team has decided
        <emphasis>not to implement multiple domains</emphasis> at this
        time.  If there is no way to privilege separate users, then
        all users have access to all resources anyway.  Hence,
        security is not made any better.
      </para>
      <para>
        Of further note, OpenHPI is expected to be utilized and
        productized by many different organizations for different
        purposes.  Given this, it seems counter productive to have
        OpenHPI itself enforce policy about what qualifies as a
        Domain.  There are ideas about how multiple domains will be
        implemented in OpenHPI in the future, and how site admins will
        be able to configure the domain structure to fit their site
        policy.  If you wish to participate in this element of design,
        please join our mailing list and speak up.  We are more than
        happy to accept new volunteers.
      </para>
    </sect1>
    <sect1>
      <title>SA HPI Data Structures</title>
      <sect2>
        <title>RPT Data Structures</title>
        <para>
          The following is an unrolling of SA HPI Data Structures
          surrounding the RPT.  For sake of sanity, it is unrolled only
          as far as the high level RDR types.  Those are broken down later.
        </para>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/saf_hpi_rpt.png">
        </imageobject>
      </mediaobject>
    </sect2>
  </sect1>
</chapter>
