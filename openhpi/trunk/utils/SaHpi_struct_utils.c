/*      -*- linux-c -*-
 *
 * (C) Copyright IBM Corp. 2004
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  This
 * file and program are licensed under a BSD style license.  See
 * the Copying file included with the OpenHPI distribution for
 * full licensing terms.
 *
 * Author(s):
 *      Sean Dague <sdague@users.sf.net>
 *      Steve Sherman <stevees@us.ibm.com>
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

#include <SaHpi.h>
#include <SaHpi_struct_utils.h>

/*************************************************************
 * Simple print and validation routines are contained in 
 * SaHpi_enum_utils.c, which is generated by the build process.
 * Those routines which cannot be automated easily reside here.
 *************************************************************/

/**
 * SaHpiTimeT2str:
 * @time: SaHpiTimeT time to be converted                     
 * @buffer: location to store the converted string
 * @buffer_size: Size of buffer to hold the date/time string
 *
 * Converts an SaHpiTimeT time value to the preferred date/time string 
 * time representation defined for the current locale.
 * 
 * Returns: SA_ERR_HPI_INVALID_PARAMS - if buffer is NULL
 *          SA_ERR_HPI_OUT_OF_SPACE - if buffer_size not big enough to accomodate
 *                                    date/time representation string
 **/
SaErrorT SaHpiTimeT2str(SaHpiTimeT time, char *buffer, size_t buffer_size)
{
	struct tm t;
	time_t tt;
	int count;

	tt = time / 1000000000;
	localtime_r(&tt, &t);
	
	if (!buffer) {
		return(SA_ERR_HPI_INVALID_PARAMS);
	}
	
	count = strftime(buffer, buffer_size, "%c", &t);
	if (count == 0) {
		return(SA_ERR_HPI_OUT_OF_SPACE);
	}
	
	return(SA_OK);
}

/**
 * SaHpiManufacturerIdT2str:
 * @value: enum value of type SaHpiManufacturerIdT.
 *
 * Converts "value" into its HPI enum string definition.  
 * 
 * Returns: HPI enum string definition.
 *          NULL - if "value" not a valid SaHpiManufacturerIdT.
 **/
const char *SaHpiManufacturerIdT2str(SaHpiManufacturerIdT  value) 
{
	switch (value) {
       /* Add your favorite manufacturer from 
        * http://www.iana.org/assignments/enterprise-numbers */
	case SAHPI_MANUFACTURER_ID_UNSPECIFIED:
		return("SAHPI_MANUFACTURER_ID_UNSPECIFIED");
	case 2:
		return("IBM");
	default:
		return("Undefined Manufacturer");
	}
}

/**
 * valid_SaHpiEventStateT4Cat:
 * @event_state: Event state bit field.
 * @event_cat: Event's category.
 * 
 * Validates that all the event(s) in the event_state bit field are valid
 * for the event category. Routine also checks for mutually exclusive
 * events and that thresholds events have all the appropriate
 * lower-level threshold event states set.
 * 
 * Returns: SAHPI_TRUE  - if event(s) valid for category and met HPI spec
 *                        criteria for exclusiveness and completeness.
 *          SAHPI_FALSE - if any event(s) in bit field not valid for category
 *                        of the category is invalid.
 **/
SaHpiBoolT valid_SaHpiEventStateT4Cat(SaHpiEventStateT event_state,
				      SaHpiEventCategoryT event_cat)
{
	SaHpiEventStateT valid_states;

	switch(event_cat) {
	case SAHPI_EC_UNSPECIFIED:
		/* Only SAHPI_ES_UNSPECIFIED valid for this category */
		if (event_state) {
			return(SAHPI_FALSE);
		}
		return(SAHPI_TRUE);

	case SAHPI_EC_THRESHOLD:
		valid_states = SAHPI_ES_LOWER_MINOR |
			       SAHPI_ES_LOWER_MAJOR |
			       SAHPI_ES_LOWER_CRIT |
			       SAHPI_ES_UPPER_MINOR |
			       SAHPI_ES_UPPER_MAJOR |
  			       SAHPI_ES_UPPER_CRIT;

		if (event_state & (~valid_states)) {
			return(SAHPI_FALSE);
		}

		/* Check that all lower-level thresholds are set */
		if (event_state & SAHPI_ES_LOWER_CRIT) {
			if (!(event_state & SAHPI_ES_LOWER_MAJOR)) {
				return(SAHPI_FALSE);
			}
		}
		if (event_state & SAHPI_ES_LOWER_MAJOR) {
			if (!(event_state & SAHPI_ES_LOWER_MINOR)) {
				return(SAHPI_FALSE);
			}
		}
		if (event_state & SAHPI_ES_UPPER_CRIT) {
			if (!(event_state & SAHPI_ES_UPPER_MAJOR)) {
				return(SAHPI_FALSE);
			}
		}
		if (event_state & SAHPI_ES_UPPER_MAJOR) {
			if (!(event_state & SAHPI_ES_UPPER_MINOR)) {
				return(SAHPI_FALSE);
			}
		}
		
		/* FIXME:: This let's things that have both upper and lower
		   thresholds set thru - is this valid? */
		return(SAHPI_TRUE);

	case SAHPI_EC_USAGE:
		valid_states = SAHPI_ES_IDLE |
			       SAHPI_ES_ACTIVE |
			       SAHPI_ES_BUSY;

		/* FIXME:: Are these mutally exclusive states?? */
		if (event_state & (~valid_states)) {
			return(SAHPI_FALSE);
		}
		
		return(SAHPI_TRUE);

	case SAHPI_EC_STATE:
		valid_states = SAHPI_ES_STATE_DEASSERTED |
			       SAHPI_ES_STATE_ASSERTED;
		
		if (event_state & (~valid_states)) {
			return(SAHPI_FALSE);
		}
		
		/* Enforce mutual exclusion */
		if ((event_state & SAHPI_ES_STATE_DEASSERTED) &&
		    (event_state & SAHPI_ES_STATE_ASSERTED)) {
			return(SAHPI_FALSE);		
		}

		return(SAHPI_TRUE);

	case SAHPI_EC_PRED_FAIL:
		valid_states = SAHPI_ES_PRED_FAILURE_DEASSERT |
			       SAHPI_ES_PRED_FAILURE_ASSERT;

		if (event_state & (~valid_states)) {
			return(SAHPI_FALSE);
		}
		
		/* Enforce mutual exclusion */
		if ((event_state & SAHPI_ES_PRED_FAILURE_DEASSERT) &&
		    (event_state & SAHPI_ES_PRED_FAILURE_ASSERT)) {
			return(SAHPI_FALSE);		
		}

		return(SAHPI_TRUE);

	case SAHPI_EC_LIMIT:
		valid_states = SAHPI_ES_LIMIT_NOT_EXCEEDED |
			       SAHPI_ES_LIMIT_EXCEEDED;

		if (event_state & (~valid_states)) {
			return(SAHPI_FALSE);
		}
		
		/* Enforce mutual exclusion */
		if ((event_state & SAHPI_ES_LIMIT_NOT_EXCEEDED) &&
		    (event_state & SAHPI_ES_LIMIT_EXCEEDED)) {
			return(SAHPI_FALSE);		
		}

		return(SAHPI_TRUE);

	case SAHPI_EC_PERFORMANCE:
		valid_states = SAHPI_ES_PERFORMANCE_MET |
			       SAHPI_ES_PERFORMANCE_LAGS;

		if (event_state & (~valid_states)) {
			return(SAHPI_FALSE);
		}
		
		/* Enforce mutual exclusion */
		if ((event_state & SAHPI_ES_PERFORMANCE_MET) &&
		    (event_state & SAHPI_ES_PERFORMANCE_LAGS)) {
			return(SAHPI_FALSE);		
		}

		return(SAHPI_TRUE);

	case SAHPI_EC_SEVERITY:
		/* FIXME :: Any of these exclusive??? */
		valid_states = SAHPI_ES_OK |
			       SAHPI_ES_MINOR_FROM_OK |
                               SAHPI_ES_MAJOR_FROM_LESS |
                               SAHPI_ES_CRITICAL_FROM_LESS |
                               SAHPI_ES_MINOR_FROM_MORE |
                               SAHPI_ES_MAJOR_FROM_CRITICAL |
                               SAHPI_ES_CRITICAL |
                               SAHPI_ES_MONITOR |
                               SAHPI_ES_INFORMATIONAL;

		if (event_state & (~valid_states)) {
			return(SAHPI_FALSE);
		}

		return(SAHPI_TRUE);

	case SAHPI_EC_PRESENCE:
		valid_states = SAHPI_ES_ABSENT |
			       SAHPI_ES_PRESENT;

		if (event_state & (~valid_states)) {
			return(SAHPI_FALSE);
		}
		
		/* Enforce mutual exclusion */
		if ((event_state & SAHPI_ES_ABSENT) &&
		    (event_state & SAHPI_ES_PRESENT)) {
			return(SAHPI_FALSE);		
		}

		return(SAHPI_TRUE);

	case SAHPI_EC_ENABLE:
		valid_states = SAHPI_ES_DISABLED |
			       SAHPI_ES_ENABLED;

		if (event_state & (~valid_states)) {
			return(SAHPI_FALSE);
		}
		
		/* Enforce mutual exclusion */
		if ((event_state & SAHPI_ES_DISABLED) &&
		    (event_state & SAHPI_ES_ENABLED)) {
			return(SAHPI_FALSE);		
		}

		return(SAHPI_TRUE);

	case SAHPI_EC_AVAILABILITY:
		/* FIXME:: Any of these exclusive? */
		valid_states = SAHPI_ES_RUNNING |
			       SAHPI_ES_TEST |
			       SAHPI_ES_POWER_OFF |
			       SAHPI_ES_ON_LINE |
			       SAHPI_ES_OFF_LINE |
			       SAHPI_ES_OFF_DUTY |
			       SAHPI_ES_DEGRADED |
			       SAHPI_ES_POWER_SAVE |
			       SAHPI_ES_INSTALL_ERROR;

		if (event_state & (~valid_states)) {
			return(SAHPI_FALSE);
		}
		
		return(SAHPI_TRUE);

	case SAHPI_EC_REDUNDANCY:
		/* FIXME:: Any of these exclusive??? */
		valid_states = SAHPI_ES_FULLY_REDUNDANT |
			       SAHPI_ES_REDUNDANCY_LOST |
			       SAHPI_ES_REDUNDANCY_DEGRADED |
		  	       SAHPI_ES_REDUNDANCY_LOST_SUFFICIENT_RESOURCES |
			       SAHPI_ES_NON_REDUNDANT_SUFFICIENT_RESOURCES |
			       SAHPI_ES_NON_REDUNDANT_INSUFFICIENT_RESOURCES |
			       SAHPI_ES_REDUNDANCY_DEGRADED_FROM_FULL |
			       SAHPI_ES_REDUNDANCY_DEGRADED_FROM_NON;

		if (event_state & (~valid_states)) {
			return(SAHPI_FALSE);
		}
		
		return(SAHPI_TRUE);

	case SAHPI_EC_SENSOR_SPECIFIC:
	case SAHPI_EC_GENERIC:
		valid_states = SAHPI_ES_STATE_00 |
			       SAHPI_ES_STATE_01 |
			       SAHPI_ES_STATE_02 |
			       SAHPI_ES_STATE_03 |
			       SAHPI_ES_STATE_04 |
			       SAHPI_ES_STATE_05 |
			       SAHPI_ES_STATE_06 |
			       SAHPI_ES_STATE_07 |
			       SAHPI_ES_STATE_08 |
			       SAHPI_ES_STATE_09 |
			       SAHPI_ES_STATE_10 |
			       SAHPI_ES_STATE_11 |
			       SAHPI_ES_STATE_12 |
			       SAHPI_ES_STATE_13 |
			       SAHPI_ES_STATE_14;

		if (event_state & (~valid_states)) {
			return(SAHPI_FALSE);
		}
		
		return(SAHPI_TRUE);

	default:
		return(SAHPI_FALSE);
	}
}

/**
 * SaHpiEventStateT2str:
 * @event_state: Event state bit field.
 * @event_cat: Event's category.
 * @buffer: Character buffer (caller must free).
 * @buffer_size: Character buffer's size (in bytes).
 * 
 * Converts a bit field of event states into a character buffer.
 * 
 * Returns: SA_OK - normal operation
 *          SA_ERR_HPI_OUT_OF_SPACE - if buffer too small to hold string.
 *          SA_ERR_HPI_INVALID_DATA - if event(s) not valid for category
 *                                    or invalid category.
 **/
SaErrorT SaHpiEventStateT2str(SaHpiEventStateT event_state, 
			      SaHpiEventCategoryT event_cat,
			      char *buffer,
			      int buffer_size)
{
	int  count;
	char working[OPENHPI_MAX_STRING_BUFFER]; /* Must be bigger than max string size */
	                                         /* No check for overflow */

	/* Check for valid state and category */
	if (!valid_SaHpiEventStateT4Cat(event_state, event_cat)) {
		return(SA_ERR_HPI_INVALID_DATA);
	}

	memset(working, 0, OPENHPI_MAX_STRING_BUFFER);
	count = 0;

	if (event_state == SAHPI_ES_UNSPECIFIED) {
		strcat(working, "SAHPI_ES_UNSPECIFIED ");
		count = count + strlen("SAHPI_ES_UNSPECIFIED ");
	}

	switch(event_cat) {
	case SAHPI_EC_UNSPECIFIED:
		break;

	case SAHPI_EC_THRESHOLD:
		if (event_state & SAHPI_ES_LOWER_CRIT) {
			strcat(working, "SAHPI_ES_LOWER_CRIT ");
			count = count + strlen("SAHPI_ES_LOWER_CRIT ");
		}
		if (event_state & SAHPI_ES_LOWER_MAJOR) {
			strcat(working, "SAHPI_ES_LOWER_MAJOR ");
			count = count + strlen("SAHPI_ES_LOWER_MAJOR ");
		}
		if (event_state & SAHPI_ES_LOWER_MINOR) {
			strcat(working, "SAHPI_ES_LOWER_MINOR ");
			count = count + strlen("SAHPI_ES_LOWER_MINOR ");
		}
		if (event_state & SAHPI_ES_UPPER_CRIT) {
			strcat(working, "SAHPI_ES_UPPER_CRIT ");
			count = count + strlen("SAHPI_ES_UPPER_CRIT ");
		}
		if (event_state & SAHPI_ES_UPPER_MAJOR) {
			strcat(working, "SAHPI_ES_UPPER_MAJOR ");
			count = count + strlen("SAHPI_ES_UPPER_MAJOR ");
		}
		if (event_state & SAHPI_ES_UPPER_MINOR) {
			strcat(working, "SAHPI_ES_UPPER_MINOR ");
			count = count + strlen("SAHPI_ES_UPPER_MINOR ");
		}
		
		break;
		
	case SAHPI_EC_USAGE:
		if (event_state & SAHPI_ES_IDLE) {
			strcat(working, "SAHPI_ES_IDLE ");
			count = count + strlen("SAHPI_ES_IDLE ");
		}
		if (event_state & SAHPI_ES_ACTIVE) {
			strcat(working, "SAHPI_ES_ACTIVE ");
			count = count + strlen("SAHPI_ES_ACTIVE ");
		}
		if (event_state & SAHPI_ES_BUSY) {
			strcat(working, "SAHPI_ES_BUSY ");
			count = count + strlen("SAHPI_ES_BUSY ");
		}
		
		break;

	case SAHPI_EC_STATE:
		if (event_state & SAHPI_ES_STATE_DEASSERTED) {
			strcat(working, "SAHPI_ES_STATE_DEASSERTED ");
			count = count + strlen("SAHPI_ES_STATE_DEASSERTED ");
		}
		if (event_state & SAHPI_ES_STATE_ASSERTED) {
			strcat(working, "SAHPI_ES_STATE_ASSERTED ");
			count = count + strlen("SAHPI_ES_STATE_ASSERTED ");
		}
		
		break;

	case SAHPI_EC_PRED_FAIL:
		if (event_state & SAHPI_ES_PRED_FAILURE_DEASSERT) {
			strcat(working, "SAHPI_ES_PRED_FAILURE_DEASSERT ");
			count = count + strlen("SAHPI_ES_PRED_FAILURE_DEASSERT ");
		}
		if (event_state & SAHPI_ES_PRED_FAILURE_ASSERT) {
			strcat(working, "SAHPI_ES_PRED_FAILURE_ASSERT ");
			count = count + strlen("SAHPI_ES_PRED_FAILURE_ASSERT ");
		}
		
		break;

	case SAHPI_EC_LIMIT:
		if (event_state & SAHPI_ES_LIMIT_NOT_EXCEEDED) {
			strcat(working, "SAHPI_ES_LIMIT_NOT_EXCEEDED ");
			count = count + strlen("SAHPI_ES_LIMIT_NOT_EXCEEDED ");
		}
		if (event_state & SAHPI_ES_LIMIT_EXCEEDED) {
			strcat(working, "SAHPI_ES_LIMIT_EXCEEDED ");
			count = count + strlen("SAHPI_ES_LIMIT_EXCEEDED ");
		}

		break;

	case SAHPI_EC_PERFORMANCE:
		if (event_state & SAHPI_ES_PERFORMANCE_MET) {
			strcat(working, "SAHPI_ES_PERFORMANCE_MET ");
			count = count + strlen("SAHPI_ES_PERFORMANCE_MET ");
		}
		if (event_state & SAHPI_ES_PERFORMANCE_LAGS) {
			strcat(working, "SAHPI_ES_PERFORMANCE_LAGS ");
			count = count + strlen("SAHPI_ES_PERFORMANCE_LAGS ");
		}

		break;

	case SAHPI_EC_SEVERITY:
		if (event_state & SAHPI_ES_OK) {
			strcat(working, "SAHPI_ES_OK ");
			count = count + strlen("SAHPI_ES_OK ");
		}
		if (event_state & SAHPI_ES_MINOR_FROM_OK) {
			strcat(working, "SAHPI_ES_MINOR_FROM_OK ");
			count = count + strlen("SAHPI_ES_MINOR_FROM_OK ");
		}
		if (event_state & SAHPI_ES_MAJOR_FROM_LESS) {
			strcat(working, "SAHPI_ES_MAJOR_FROM_LESS ");
			count = count + strlen("SAHPI_ES_MAJOR_FROM_LESS ");
		}
		if (event_state & SAHPI_ES_CRITICAL_FROM_LESS) {
			strcat(working, "SAHPI_ES_CRITICAL_FROM_LESS ");
			count = count + strlen("SAHPI_ES_CRITICAL_FROM_LESS ");
		}
		if (event_state & SAHPI_ES_MINOR_FROM_MORE) {
			strcat(working, "SAHPI_ES_MINOR_FROM_MORE ");
			count = count + strlen("SAHPI_ES_MINOR_FROM_MORE ");
		}
		if (event_state & SAHPI_ES_MAJOR_FROM_CRITICAL) {
			strcat(working, "SAHPI_ES_MAJOR_FROM_CRITICAL ");
			count = count + strlen("SAHPI_ES_MAJOR_FROM_CRITICAL ");
		}
		if (event_state & SAHPI_ES_CRITICAL) {
			strcat(working, "SAHPI_ES_CRITICAL ");
			count = count + strlen("SAHPI_ES_CRITICAL ");
		}
		if (event_state & SAHPI_ES_MONITOR) {
			strcat(working, "SAHPI_ES_MONITOR ");
			count = count + strlen("SAHPI_ES_MONITOR ");
		}
		if (event_state & SAHPI_ES_INFORMATIONAL) {
			strcat(working, "SAHPI_ES_INFORMATIONAL ");
			count = count + strlen("SAHPI_ES_INFORMATIONAL ");
		}

		break;

	case SAHPI_EC_PRESENCE:
		if (event_state & SAHPI_ES_ABSENT) {
			strcat(working, "SAHPI_ES_ABSENT ");
			count = count + strlen("SAHPI_ES_ABSENT ");
		}
		if (event_state & SAHPI_ES_PRESENT) {
			strcat(working, "SAHPI_ES_PRESENT ");
			count = count + strlen("SAHPI_ES_PRESENT ");
		}

		break;

	case SAHPI_EC_ENABLE:
		if (event_state & SAHPI_ES_DISABLED) {
			strcat(working, "SAHPI_ES_DISABLED ");
			count = count + strlen("SAHPI_ES_DISABLED ");
		}
		if (event_state & SAHPI_ES_ENABLED) {
			strcat(working, "SAHPI_ES_ENABLED ");
			count = count + strlen("SAHPI_ES_ENABLED ");
		}

		break;

		return(SAHPI_TRUE);

	case SAHPI_EC_AVAILABILITY:
		if (event_state & SAHPI_ES_RUNNING) {
			strcat(working, "SAHPI_ES_RUNNING ");
			count = count + strlen("SAHPI_ES_RUNNING ");
		}
		if (event_state & SAHPI_ES_TEST) {
			strcat(working, "SAHPI_ES_TEST ");
			count = count + strlen("SAHPI_ES_TEST ");
		}
		if (event_state & SAHPI_ES_POWER_OFF) {
			strcat(working, "SAHPI_ES_POWER_OFF ");
			count = count + strlen("SAHPI_ES_POWER_OFF ");
		}
		if (event_state & SAHPI_ES_ON_LINE) {
			strcat(working, "SAHPI_ES_ON_LINE ");
			count = count + strlen("SAHPI_ES_ON_LINE ");
		}
		if (event_state & SAHPI_ES_OFF_LINE) {
			strcat(working, "SAHPI_ES_OFF_LINE ");
			count = count + strlen("SAHPI_ES_OFF_LINE ");
		}
		if (event_state & SAHPI_ES_OFF_DUTY) {
			strcat(working, "SAHPI_ES_OFF_DUTY ");
			count = count + strlen("SAHPI_ES_OFF_DUTY ");
		}
		if (event_state & SAHPI_ES_DEGRADED) {
			strcat(working, "SAHPI_ES_DEGRADED ");
			count = count + strlen("SAHPI_ES_DEGRADED ");
		}
		if (event_state & SAHPI_ES_POWER_SAVE) {
			strcat(working, "SAHPI_ES_POWER_SAVE ");
			count = count + strlen("SAHPI_ES_POWER_SAVE ");
		}
		if (event_state & SAHPI_ES_INSTALL_ERROR) {
			strcat(working, "SAHPI_ES_INSTALL_ERROR ");
			count = count + strlen("SAHPI_ES_INSTALL_ERROR ");
		}

		break;

	case SAHPI_EC_REDUNDANCY:
		if (event_state & SAHPI_ES_FULLY_REDUNDANT) {
			strcat(working, "SAHPI_ES_FULLY_REDUNDANT ");
			count = count + strlen("SAHPI_ES_FULLY_REDUNDANT ");
		}
		if (event_state & SAHPI_ES_REDUNDANCY_LOST) {
			strcat(working, "SAHPI_ES_REDUNDANCY_LOST ");
			count = count + strlen("SAHPI_ES_REDUNDANCY_LOST ");
		}
		if (event_state & SAHPI_ES_REDUNDANCY_DEGRADED) {
			strcat(working, "SAHPI_ES_REDUNDANCY_DEGRADED ");
			count = count + strlen("SAHPI_ES_REDUNDANCY_DEGRADED ");
		}
		if (event_state & SAHPI_ES_REDUNDANCY_LOST_SUFFICIENT_RESOURCES) {
			strcat(working, "SAHPI_ES_REDUNDANCY_LOST_SUFFICIENT_RESOURCES ");
			count = count + strlen("SAHPI_ES_REDUNDANCY_LOST_SUFFICIENT_RESOURCES ");
		}
		if (event_state & SAHPI_ES_NON_REDUNDANT_SUFFICIENT_RESOURCES) {
			strcat(working, "SAHPI_ES_NON_REDUNDANT_SUFFICIENT_RESOURCES ");
			count = count + strlen("SAHPI_ES_NON_REDUNDANT_SUFFICIENT_RESOURCES ");
		}
		if (event_state & SAHPI_ES_NON_REDUNDANT_INSUFFICIENT_RESOURCES) {
			strcat(working, "SAHPI_ES_NON_REDUNDANT_INSUFFICIENT_RESOURCES ");
			count = count + strlen("SAHPI_ES_NON_REDUNDANT_INSUFFICIENT_RESOURCES ");
		}
		if (event_state & SAHPI_ES_REDUNDANCY_DEGRADED_FROM_FULL) {
			strcat(working, "SAHPI_ES_REDUNDANCY_DEGRADED_FROM_FULL ");
			count = count + strlen("SAHPI_ES_REDUNDANCY_DEGRADED_FROM_FULL ");
		}
		if (event_state & SAHPI_ES_REDUNDANCY_DEGRADED_FROM_NON) {
			strcat(working, "SAHPI_ES_REDUNDANCY_DEGRADED_FROM_NON ");
			count = count + strlen("SAHPI_ES_REDUNDANCY_DEGRADED_FROM_NON ");
		}

		break;

	case SAHPI_EC_SENSOR_SPECIFIC:
	case SAHPI_EC_GENERIC:
		if (event_state & SAHPI_ES_STATE_00) {
			strcat(working, "SAHPI_ES_STATE_00 ");
			count = count + strlen("SAHPI_ES_STATE_00 ");
		}
		if (event_state & SAHPI_ES_STATE_01) {
			strcat(working, "SAHPI_ES_STATE_01 ");
			count = count + strlen("SAHPI_ES_STATE_01 ");
		}
		if (event_state & SAHPI_ES_STATE_02) {
			strcat(working, "SAHPI_ES_STATE_02 ");
			count = count + strlen("SAHPI_ES_STATE_02 ");
		}
		if (event_state & SAHPI_ES_STATE_03) {
			strcat(working, "SAHPI_ES_STATE_03 ");
			count = count + strlen("SAHPI_ES_STATE_03 ");
		}
		if (event_state & SAHPI_ES_STATE_04) {
			strcat(working, "SAHPI_ES_STATE_04 ");
			count = count + strlen("SAHPI_ES_STATE_04 ");
		}
		if (event_state & SAHPI_ES_STATE_05) {
			strcat(working, "SAHPI_ES_STATE_05 ");
			count = count + strlen("SAHPI_ES_STATE_05 ");
		}
		if (event_state & SAHPI_ES_STATE_06) {
			strcat(working, "SAHPI_ES_STATE_06 ");
			count = count + strlen("SAHPI_ES_STATE_06 ");
		}
		if (event_state & SAHPI_ES_STATE_07) {
			strcat(working, "SAHPI_ES_STATE_07 ");
			count = count + strlen("SAHPI_ES_STATE_07 ");
		}
		if (event_state & SAHPI_ES_STATE_08) {
			strcat(working, "SAHPI_ES_STATE_08 ");
			count = count + strlen("SAHPI_ES_STATE_08 ");
		}
		if (event_state & SAHPI_ES_STATE_09) {
			strcat(working, "SAHPI_ES_STATE_09 ");
			count = count + strlen("SAHPI_ES_STATE_09 ");
		}
		if (event_state & SAHPI_ES_STATE_10) {
			strcat(working, "SAHPI_ES_STATE_10 ");
			count = count + strlen("SAHPI_ES_STATE_10 ");
		}
		if (event_state & SAHPI_ES_STATE_11) {
			strcat(working, "SAHPI_ES_STATE_11 ");
			count = count + strlen("SAHPI_ES_STATE_11 ");
		}
		if (event_state & SAHPI_ES_STATE_12) {
			strcat(working, "SAHPI_ES_STATE_12 ");
			count = count + strlen("SAHPI_ES_STATE_12 ");
		}
		if (event_state & SAHPI_ES_STATE_13) {
			strcat(working, "SAHPI_ES_STATE_13 ");
			count = count + strlen("SAHPI_ES_STATE_13 ");
		}
		if (event_state & SAHPI_ES_STATE_14) {
			strcat(working, "SAHPI_ES_STATE_14 ");
			count = count + strlen("SAHPI_ES_STATE_14 ");
		}

		break;

	default:
		/* Should never get here */
		return(SA_ERR_HPI_INTERNAL_ERROR);
	}

 	if (count > buffer_size - 1) {
		return(SA_ERR_HPI_OUT_OF_SPACE);
	}

	strncpy(buffer, working, count);

	return(SA_OK);
}


#if 0

SaHpiBoolT valid_SaHpiTextBufferT(SaHpiTextBufferT text_buffer) {

	if (!valid_SaHpiTextTypeT) { return(SAHPI_FALSE); }
	if (!valid_SaHpiLanguageT) { return(SAHPI_FALSE); }
	/* Compiler checks DataLength <= SAHPI_MAX_TEXT_BUFFER_LENGTH */

	switch(text_buffer.DataType){
	case SAHPI_TL_TYPE_UNICODE:
		
		/* FIXME:: Verify unicode characters in Data */
		/* g_unichar_validate(gunichar ch); */
		break;
	case SAHPI_TL_TYPE_BCDPLUS:

		/* FIXME:: Verify BCDPLUS characters in Data */
		/* '0'-'9' or space, dash, period, colon, comma, or
		   underscore only.*/
		break;
	case SAHPI_TL_TYPE_ASCII6:
		/* FIXME:: Verify reduced character set in Data */
		/* reduced set, 0x20-0x5f only. */
		break;
	case SAHPI_TL_TYPE_TEXT:
		/* FIXME:: Any check possible for ASCII + Latin 1? */
		break;
	case SAHPI_TL_TYPE_BINARY: /* No check possible */
		break;
	default: /* Impossible state */
		return(SA_ERR_HPI_INTERNAL_ERROR);
	}

	return(SAHPI_TRUE);
}

SaErrorT print_SaHpiTextBufferT(SaHpiTextBufferT text_buffer) {

	SaHpiUint8T Data[SAHPI_MAX_TEXT_BUFFER_LENGTH];
	
	memset(Data, 0, SAHPI_MAX_TEXT_BUFFER_LENGTH);
        memcpy(Data, text_buffer.Data, text_buffer.DataLength);

	printf("TextBuffer:\n");
	printf("\tDataType: %s\n", SaHpiTextTypeT_2str(text_buffer.DataType));
	printf("\tLanguage: %s\n", SaHpiLanguageT_2str(text_buffer.Language));
	printf("\tDataLength: %d\n", text_buffer.DataLength);

	switch (text_buffer.DataType) {	
	case SAHPI_TL_TYPE_UNICODE:
		/* FIXME:: print unicode */
		break;
	case SAHPI_TL_TYPE_BCDPLUS:
	case SAHPI_TL_TYPE_ASCII6:
	case SAHPI_TL_TYPE_TEXT:
		printf("\tData: %s\n", Data);
		break;
	case SAHPI_TL_TYPE_BINARY:
		printf("\tData: %x\n", Data);
		break;
	default:
		printf("\tData: ERROR! Invalid HPI SaHpiTextTypeT type\n");
	}

	return SA_OK;
}

#endif
